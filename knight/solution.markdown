### Задача

Шахматный конь &mdash; это фигура, которая одним ходом может
переместиться на две клетки по горизонтали и одну по вертикали,
или же наоборот &mdash; на одну клетку по горизонтали и две по вертикали.

```
 a8  b8  c8  d8  e8  f8  g8  h8
 a7  b7  c7  d7  e7  f7  g7  h7
[a6] b6 [c6] d6  e6  f6  g6  h6
 a5  b5  c5 [d5] e5  f5  g5  h5
 a4 <b4> c4  d4  e4  f4  g4  h4
 a3  b3  c3 [d3] e3  f3  g3  h3
[a2] b2 [c2] d2  e2  f2  g2  h2
 a1  b1  c1  d1  e1  f1  g1  h1
```

Например, из клетки `b4` (отмечена угловыми скобками) конь может походить
в одну из следующих клеток (отмечены квадратными скобками):
`a2`, `c2`, `d3`,
`d5`, `a6`, `c6`.

Сейчас конь стоит на шахматной доске в клетке A.
Конь очень хочет как можно скорее оказаться в другой клетке, B.
Через какое минимальное количество ходов он может там оказаться?

В первой строке задана клетка A, а во второй &mdash; клетка B.
Клетка обозначается двумя символами:
именем столбца (одна из букв `abcdefgh`)
и номером ряда (одна из цифр `12345678`).

Пример ввода:

```
b4
f2
```

Пример вывода:

```
2
```

### Решение

Будем решать задачу поиском в ширину.

Напишем шапку.
В программе понадобится ввод-вывод, а также структуры данных
&laquo;очередь&raquo;, &laquo;пара&raquo; и &laquo;вектор&laquo;.

```
#include <iostream>
#include <queue>
#include <utility>
#include <vector>
using namespace std;

int main ()
{
```

Прочитаем входные данные.
В `srow` &mdash; запишем номер начального ряда от 0 до 7,
а в `scol` &madsh; номер начального столбца от 0 до 7.
В `frow` и `fcol` запишем номер конечного ряда и конечного столбца.

```
	string start, finish;
	cin >> start >> finish;
	int srow = start[1] - '1';
	int scol = start[0] - 'a';
	int frow = finish[1] - '1';
	int fcol = finish[0] - 'a';
```

Заведём таблицу `8 x 8` &mdash; того же размера, что и шахматная доска.
В каждой клетке будем хранить расстояние от начальной клетки до неё.
Изначально в каждую клетку запишем
какое-то &laquo;бесконечное&raquo; расстояние &mdash;
больше, чем всё, что бывает на самом деле,
например, 99 &mdash; а в начальную запишем 0.

```
	int const infinity = 99;
	vector <vector <int> > dist (8, vector <int> (8, infinity));
	dist[srow][scol] = 0;
```

Кроме того, заведём _очередь_ из клеток, записывая координаты
в `pair <int, int>`.
Сначала положим в очередь начальную клетку.

```
	queue <pair <int, int> > q;
	q.push ({srow, scol});
```

Из каждой клетки нужно будет попробовать сделать восемь ходов коня.
Запишем, как эти ходы меняют номер строки и номер столбца.
Например, `drow[0]` уменьшает номер строки на 2,
а `dcol[0]` уменьшает номер столбца на 1,
и вместе они составляют один из восьми возможных ходов.
Чтобы не запутаться, можно перечислить ходы против часовой стрелки.

```
	vector <int> const drow = {-2, -1, +1, +2, +2, +1, -1, -2};
	vector <int> const dcol = {-1, -2, -2, -1, +1, +2, +2, +1};
```

Алгоритм будет брать очередную клетку `(row, col)` из очереди,
пока она есть, и убирать эту клетку из очереди.

```
	while (!q.empty ())
	{
		int row = q.front ().first;
		int col = q.front ().second;
		q.pop ();
```

Для каждого из восьми ходов посмотрим, в какую клетку `(nrow, ncol)`
он нас приводит, и есть ли вообще эта клетка на доске.

```
		for (int dir = 0; dir < 8; dir++)
		{
			int nrow = row + drow[dir];
			int ncol = col + dcol[dir];
			if (0 <= nrow && nrow <= 7 && 0 <= ncol && ncol <= 7)
			{
```

Если мы ещё не были в этой клетке, то расстояние до неё
всё ещё равно &laquo;бесконечности&raquo;. 
В таком случае добавим клетку в очередь и запишем, что расстояние до неё
на единицу больше, чем расстояние до клетки `(row, col)`.
Иначе просто ничего не будем делать, так как расстояние до этой клетки
уже посчитано, и она уже добавлена в очередь.

```
				if (dist[nrow][ncol] == infinity)
				{
					dist[nrow][ncol] = dist[row][col] + 1;
					q.push ({nrow, ncol});
				}
			}
		}
	}
```

Оказывается, что это всё, что нужно.
Когда очередь опустела, мы посчитали расстояния до всех клеток.
Давайте выведем их &mdash; для себя в `cerr`, просто чтобы убедиться,
что наша программа работает.

```
	for (int row = 7; row >= 0; row--)
	{
		for (int col = 0; col < 8; col++)
		{
			cerr << dist[row][col] << " ";
		}
		cerr << endl;
	}
```

Вот что получается в примере:

```
3 2 3 2 3 4 3 4 
2 3 2 3 2 3 4 3 
1 2 1 4 3 2 3 4 
2 3 2 1 2 3 4 3 
3 0 3 2 3 2 3 4 
2 3 2 1 2 3 4 3 
1 2 1 4 3 2 3 4 
2 3 2 3 2 3 4 3 
```

Выведем ответ &mdash; расстояние до конечной клетки.

```
	cout << dist[frow][fcol] << endl;
	return 0;
}
```

### Программа

Вот полная программа, собранная воедино из кусочков выше.

```
#include <iostream>
#include <queue>
#include <utility>
#include <vector>
using namespace std;

int main ()
{

	string start, finish;
	cin >> start >> finish;
	int srow = start[1] - '1';
	int scol = start[0] - 'a';
	int frow = finish[1] - '1';
	int fcol = finish[0] - 'a';

	int const infinity = 99;
	vector <vector <int> > dist (8, vector <int> (8, infinity));
	dist[srow][scol] = 0;

	queue <pair <int, int> > q;
	q.push ({srow, scol});

	vector <int> const drow = {-2, -1, +1, +2, +2, +1, -1, -2};
	vector <int> const dcol = {-1, -2, -2, -1, +1, +2, +2, +1};

	while (!q.empty ())
	{
		int row = q.front ().first;
		int col = q.front ().second;
		q.pop ();

		for (int dir = 0; dir < 8; dir++)
		{
			int nrow = row + drow[dir];
			int ncol = col + dcol[dir];
			if (0 <= nrow && nrow <= 7 && 0 <= ncol && ncol <= 7)
			{

				if (dist[nrow][ncol] == infinity)
				{
					dist[nrow][ncol] = dist[row][col] + 1;
					q.push ({nrow, ncol});
				}
			}
		}
	}

	for (int row = 7; row >= 0; row--)
	{
		for (int col = 0; col < 8; col++)
		{
			cerr << dist[row][col] << " ";
		}
		cerr << endl;
	}

	cout << dist[frow][fcol] << endl;
	return 0;
}
```
